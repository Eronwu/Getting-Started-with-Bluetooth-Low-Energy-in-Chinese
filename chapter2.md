# 第二章节，基本协议

虽然用户总是仅仅直接与BLE协议栈的上层接口进行交互，但最好是对整个栈开始有一个基本的概观，了解这个栈提供了一个可靠的基础来更好理解这些东西是如何操作以及原因。

正如图2-1展示，一个完整的单模BLE设备被分为三块：控制器（controller）、主机（host）和应用（application）。

*应用*

​		就像其他类型的系统一样，应用是在最高层，负责了逻辑、用户接口，以及所有与应用实现的实际用例相关的数据处理。一个应用的结构设计高度依赖于每一个特殊的实现。

*主机*

​		包含了以下层：

- 通用访问配置文件 Generic Access Profile（GAP）
- 通用属性配置文件 Generic Attribute Profile（GATT）
- 逻辑链路控制和适配协议 Logical Link Control and Adaption Protocol （L2CAP）
- 属性协议 Attribute Protocol（ATT）
- 安全管理 Security Manager（SM）
- 主机控制器接口 Host Controller Interface（HCI），主机端

*控制器*

​		包含了以下层：

- 主机控制器接口 Host Controller Interface（HCI），控制器端
- 链路层 Link Layer（LL）
- 物理层 Physical Layer（PHY）

在这一章，各部分的顺序将会从下（天线 antenna）到上（用户接口 user interface）以介绍不同的部分的方式，来组成一个BLE设备。

![figure2-1](./pic/figure2-1.png)

*图2-1. BLE协议栈*



## 物理层

物理层（PHY）是实际包含了模拟通信电路、调制解调和转化为电信号的能力。

无线通信模块使用了2.4Ghz ISM（工业Industrial、科学Scientific和医疗Medical）频段进行交流，并将2.4000GHz到2.4835Ghz的频段分割成40个信道（channels）。如图2-2，37个信道被用作数据连接，剩下3个信道（37、38、39）被用在广播信道上，用于建立连接和发送广播数据。

![figure2-2](./pic/figure2-2.png)

*图2-2. 频段*

这个标准使用了一个技术叫做：*跳频技术 Frequency-Hopping Spread Spectrum*， 无线电使用下面的这个公式，在每一个连接事件中，在频段之间跳转：

​		*信道 = （当前信道 + 跳转）取余 37 （ 原文：channel = (curr_channel + hop) mod 37 ）*

当连接建立好之后，经过通信而取得跳变的值，因此，每一次的连接该值都是不同的。这项技术大大减小了在2.4GHz频段中，通过单独一个信道下无线电干扰的可能的影响，尤其是因为在这个波段中WiFi和经典蓝牙的流行，在接近到高传输功率的其他设备下，设备可能遇到很严重的干扰。

高斯频移键控（Gaussian Frequency Shift Keying, GFSK）是指在空气中选择对码流的调制，同样的调制被使用在经典蓝牙和许多其他专有的低功耗无线协议。BLE的调制速率被固定在1Mbit/s，因此上层物理吞吐量就因为这个技术被限制。

![figure2-2-plus](./pic/figure2-2-plus.png)   *实际上，正如任何其他协议栈，当说到应用数据吞吐量，永远难以实际达到上层的极限，主要就因为在不同层上的各种协议。*



## 链路层

链路层是与PHY直接连接的部分，通常被作为软硬件定制的结合体实现。这个也是整个协议栈中唯一的硬实时约束层，因为对于遵守规格书中定义的所有时序要求，链路层是负责任的。因此它经常被依靠隐藏着来自其他层（参照后文[主机控制器接口（HCI）](#主机控制器接口（HCI）)）复杂、实时的需求的标准接口的高层协议栈部分所孤立。

硅厂商在硬件中通常实现从计算上来讲的昂贵、简易自动化的功能，以避免在运行栈中所有的软件层CPU会过载。这些功能通常包括：

- 前同步码（Preamble），访问地址（Access Address）和空中协议框架（air protocol framing）
- CRC生成和校验（CRC generation and verification）
- 数据白化（Data whitening）
- 随机码生成（Random number generation）
- AES加密（AES encryption）

链路层的一半软件部分管理着无线模块的链路状态，即设备如何与其他设备连接。一个BLE设备可以根据使用场景和要求作为一个主机（master），一个从机（slave），或者同时作为主机从机。启动连接的设备将成为主机和从机，对他们的可获得性进行广播，接受连接的将成为从机。

一个主机可以与大量从机进行连接，一个从机也可以与许多主机进行连接。通常，如智能手机或者平板的设备更趋于作为主机，而较小、简单、容量受限的设备，如独立运行的传感器常作为从机角色。

BLE在主机从机间，较低的层固有一个不对称性，因为主机需要更多的资源。这个不对称性与USB相似，USB主机相比USB设备需要更多的资源。这种结构上不对称性的类型允许廉价的外围设备在便宜的微控制器上运行，而底层协议的多数复杂性则出现在有更多资源的设备上，如智能手机和平板。

链路层定义了以下角色：

*广播者（Advertiser）*

​		发送广播数据包的设备。

*扫描者（Scanner）*

​		扫描广播数据包的设备。

*主机（Master）*

​		启动连接并且之后进行管理的设备。

*从机（Slave）*

​		接受连接请求并遵循主机时序的设备。

这些角色被有条理地组织成为两对：广播者和扫描者（当没有处在一个活动连接）以及主机和从机（当处在一个连接中）。



## 蓝牙设备地址

与以太网媒体访问控制 Ethernet Media Access Control（MAC）地址相似，蓝牙设备的基本标识符叫做 *蓝牙设备地址 Bluetooth device address*。这个48-bit（6-byte）数字唯一地标识了端中的一个设备。有两种类型的设备地址，其中一个或者两者都可以设置为特殊设备：

*公共设备地址（Public device address）*

​		相对来说这个是固定的，BR/EDR，工厂预编入的设备地址。它是必须通过IEEE注册授权认证的，在整个设备的试用期内都不会改变。

*随机设备地址（Random device address）*

​		这个地址是可以被预编入设备，或者也可以在使用期内动态产生。在BLE内这有许多实际的应用，更多请见后文[地址类型](#地址类型（Address Types）)。

每一个步骤都必须使用这两个的其中一个地址，为了能够被主机标识。



## 广播和扫描（Advertising and  Scanning）

BLE只有一个数据包格式以及两种类型的数据包（广播和数据包），这极大简化了蓝牙协议栈的实现。广播包有两种目的：

- 给应用广播那些不需要通过建立一个完整的连接的数据。
- 发现从机并连接。

每一个广播包都可以携带31字节的广播数据负载，连同基本头部信息（包括蓝牙设备地址）。这种数据包简单地在空中无目的的广播，而不需要实现了解有任何扫描到的设备的存在。数据包按照固定的一个速率发送，这个是由广播时间间隔所限定，范围从20ms到10.24s。越短的时间间隔，有着越高的广播发送频率，并使扫描者（scanner）接收到的数据的机率增加，然而这样较高的数据包传输也将转变为较高的能耗。

因为广播使用了最大极限即三个频率信道，广播者（advertiser）和扫描者（scanner）无论怎样都无法同步，仅当他们随机出现交叠了，一个广播包才可以被扫描者接收。如图2-3.

![figure2-3](./pic/figure2-3.png)

*图2-3. 广播和扫描*

扫描间隔（scan interval）和扫描窗口（scan window）参数限定了扫描设备（scanner device）将如何频繁和多久去监听一个潜在的广播数据包。广播时间间隔的数值将对功耗有一个很深的影响，因为这和无线通信模块开启的时间有着直接的关系。

规格书定义了两种类型的扫描步骤：

*被动扫描（Passive scanning）*

​		扫描者仅仅监听广播数据包，广播者从未意识到一个或者多个数据包实际上已经被扫描者接收的这个事实。

*主动扫描（Active scanning）*

​		扫描者在收到一个广播包之后发出一个扫描请求包（Scan Request packet）。广播者接收到该请求并回应一个扫描回应包（Scan Response packet）。这个额外的加倍了实际的广播者发送给扫描者负载大小，但要知道很重要的一点是，这个将不再给所有的扫描者提供，也不再发送任何用户数据给广播者。

图2-4描述了主动和被动扫描的不同之处。

![figure2-4](./pic/figure2-4.png)

*图2-4. 主动和被动扫描*

广播包类型可以根据三个不同的属性进行区分。第一个是 *可连接性 connectability*：

*可连接的（Connectable）*

​		可以根据一种广播接收包来启动连接的扫描者（scanner）。

*不可连接的（Non-connectable）*

​		不可以启动连接的扫描者（这个包仅用于广播）。

第二种属性为 *可扫描性 scannability*：

*直连（Directed）*

​		这种类型的数据包在负载中，仅包含了广播者和目标扫描者的蓝牙地址，没有用户数据。因此所有直连广播包都是可连接的。

*非直连（Undirected）*

​		这种类型的数据包不指定任何个别的扫描者，并且在负载中有包含了用户数据。

表2-1展示了不同广播包类型和他们的属性。

*表2-1. 广播包类型（Advertising Packet Types）*

| 广播包类型      | 可连接的 | 扫描的 | 直连 | GAP 名字           |
| --------------- | -------- | ------ | ---- | ------------------ |
| ADV_IND         | 是       | 是     | 否   | 可连接非直连广播   |
| ADV_DIRECT_IND  | 是       | 否     | 是   | 可连接直连广播     |
| ADV_NONCONN_IND | 否       | 否     | 否   | 不可连接非直连广播 |
| ADV_SCAN_IND    | 否       | 是     | 否   | 可扫描非直连广播   |

广播包类型被用在上层，更准确的说，GAP是区分操作模式以及定义步骤。因此后文的[模式和流程（Modes and Procedures）](#模式和流程（Modes and Procedures）)在核心部分大量使用该内容。



## 连接（Connections）

要建议一个连接，主机首先要开始扫描去寻找当前接收连接请求的广播者。广播包可以通过蓝牙地址或者广播自己的数据过滤。当一个匹配的广播从机被检测到，主机会发送一个连接请求包给从机，得到从机响应，建立这个连接。连接请求数据包包括频率跳转增量（frequency hop increment），这个确定了在连接的生命期内，主机和从机同时遵循的跳转顺序。

*连接 （connection）* 简而言之，就是主机与从机在预定的时间下数据有序交换。如图2-5，每一个交换都被称为一个*连接事件（connection event)*。

![figure2-5](./pic/figure2-5.png)

*图2-5. 连接事件*

以下三个 *连接参数（connection parameters）*是在建立连接的时候主机通信的一组关键变量：

*连接时间间隔（Connection interval）*

​		指两个开始连续连接事件之间的时间。该值的范围从7.5ms（高吞吐量）到4s（最低吞吐量但同时最少功耗）。

*从机时延（Slave latency）*

​		指从机可以选择跳过而不用担心断开连接的连接事件的数量。

*连接监测超时（Connection supervision timeout）*

​		在连接被认为丢失之前，两个接收到的无效数据包之间的最大时间。

因为在给定的区域内可能存在许多BLE设备，或者仅仅因为安全性的原因（主机或从机可能只对一组预先知道的设备感兴趣），链接层（Link Layer）实现了一个 *白名单（white list）*功能，给广播者或扫描者明确了那些感兴趣的设备地址。任何收到的不在白名单里出现的蓝牙地址的广播（扫描者收到）或者连接请求（广播者收到）数据包都将简单地丢弃。

> ### 白名单（White Lists）
>
> 这是BLE控制器（controller）中使用的一个很重要的功能，当广播（advertising）、扫描（scanning）、在两端建立连接（connection）时，白名单允许主机进行设备过滤。列表内为简单的蓝牙设备地址的数组，由主机和后期储存所组成，被控制器使用。
>
> 设备进行扫描或者启动连接都可以使用白名单来限制将被检测或可连接的设备的数量，广播设备可以使用白名单去明确哪个端可以接收到来的连接。决定白名单是否使用的设置被称为 *过滤策略（filter policy）*。本质上动作就是作为一个开关，去开启和关闭白名单的过滤功能。

协议的主力为数据包，并被用来在主从机之间双向传输用户数据。这些包由一个27字节的可用数据负载，但是协议栈附带的协议内容进一步限制了实际的用户数据量为每包（packet）20字节，尽管逻辑上时由被使用的协议所决定。

很重要的一点是，链接层是作为数据的可靠承载端。所有接收到的包通过24比特的CRC进行校验，当在一个失败传输中检测到错误，链接层会要求重传。对于重传，没有上层的限制，链接层将会重新发送包，直到接收端最终确认收到。

除了广播、扫描、建立（和销毁）连接、传输和接收数据，链接层还负责一些控制流程，包括这两个关键的进程：

*改变连接参数*

​		每一个连接都由一组主机给定的连接参数来建立，但在连接的生命期内，条件和要求都可能会改变。从机可能为了一个短时的爆炸量数据突然要求一个更高的吞吐量，或者可能检测到在不久的时间，一个较长的连接时间间隔也将满足以保持连接活跃而做相反的要求。链接层允许主从机请求新的连接参数，假如主机随时单边的设置了参数。这样，每一个连接都可以被很好的调节并在吞吐量和功耗之间达到最好平衡。

*加密*

​		安全性对于BLE来说是至关重要的，链接层通过加密链路，提供了这种安全性地交换数据。这个关键点是由主机生成和管理，链接层做好实际的数据加密和解密，并对上层透明。

这两个流程是密切相关的，因为它们每一个都要求主机两端都参与执行。链接层还处理另外的交换版本信息和内部性能的流程，因此对于主机和应用开发者来说都是透明的。



## 主机控制器接口 (Host Controller Interface, HCI)

正如[第一章](#./chapter1.md)所介绍，蓝牙规格书基于芯片数量允许多种可能的配置，主机控制器接口（HCI）就是这样的标准协议，允许主机和控制器通过一系列接口进行通信。在这层画一条界限是很合理的，正如本章先前提到，因为控制器是唯一有着硬实时要求以及与硬件层联系的模块。这意味着将其从主机中分离出来，这是经常实用的，虽然增加了一点复杂度但减少了协议栈时序的紧缩，这样更适合更多高级的CPU。

通常这种配置的例子包含了大多数智能手机、平板和个人电脑，其中主机（和应用）在主CPU中运行，控制器则在不同的硬件芯片上通过UART或USB连接。这与其他技术用到的模型相似，如WiFi或者以太网：TCP/IP协议栈运行在主处理器上，而底层则在不同的IC上实现。

蓝牙规格书定义了HCI作为一组命令（commands）和事件（events）来使主机和控制器彼此交流，也包括数据包格式和一组流程控制和其他的步骤。此外，规格书还定义了一些*传输*，每一个都为特定的物理传输（UART、USB、SDIO等）扩大了HCI的协议。

半导体技术已经变得足够便宜，允许单颗芯片包含了控制器、主机和应用，都集中在一个封装（片上系统a system-on-chip, 或者SoC）内。在许多嵌入式设备应用上，大量的集成更可取，这可以在最终的设备上减少成本和体积。就BLE来说，在低功耗CPU上使用单一芯片同时运行所有的三层内容以实现传感器，这已经司空见惯。

## 逻辑链路控制和适配协议 (Logical Link Control and Adaption Protocol, L2CAP)

逻辑链路控制和适配协议，这个相当神秘的名字，提供了两个主要的功能性。首先，它作为多路转接器（multiplexer）将上层的多种协议封装成标准蓝牙数据包格式（反之亦然）。

它也实现分裂和重组，这个进程将大量来自上层的数据包分解成块，填入传输端中最高27字节的BLE数据包负载内。在接收侧，它接收已被分解的多种数据包并重组成一个单独的大数据包，该包将被往上层发送至一个合适的主机上层实体。作一个简单的对比，L2CAP与TCP就很相似，都允许很大范围的协议在可以在单独的物理链路中无缝地共存，而每一个协议都有着不同的数据包大小和要求。

对于BLE来说，L2CAP层掌管或路由选择两个主要的协议：属性协议(Attribute Protocol, ATT)和安全管理协议(Security Manager Protocol, SMP)。ATT（在后文[属性协议（Attribute Protocol, ATT）](#属性协议（Attribute Protocol, ATT）)及进行讨论）在BLE应用中形成数据交换的基础，而SMP（在后文[安全管理协议(Security Manager Protocol, SMP)](#安全管理协议(Security Manager Protocol, SMP))及进行讨论）在端之间提供了生成和分发安全钥匙的框架。

此外，因为规格书4.1的版本，L2CAP可以为了高吞吐量的数据传输而不要求ATT增加的额外的复杂度，去创建自己定义的信道。最初这是为文件传输设计的，这个特性被称为LE基于信用的流量控制模式（LE Credit Based Flow Control Mode），这打开了因应用需求而通过BLE连接建立低功耗、大容量的信道的可能性。

从一个应用开发者的角度看，很重要的一点是，无论什么时候使用仅有默认数据包，L2CAP的数据包头（header）都占据4个字节，这意味着有效的用户数据负载（payload）为27 - 4 = 24字节（27字节为链路层的负载大小，前文[连接（Connections）](#连接（Connections）)有进行描述）。

## 属性协议（Attribute Protocol, ATT）

属性协议（Attribute Protocol, ATT）为基于设备上出现的*属性（attributes）*的简单的一个客户端/服务端（client/server， CS）的无状态协议。