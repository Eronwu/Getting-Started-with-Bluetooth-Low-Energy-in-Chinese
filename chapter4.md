# 第四章，GATT（Services and Characteristics）

通用属性配置文件（The Generic Attribuite Profile, GATT）建立在如何通过一个蓝牙连接交换所有的配置文件以及用户数据。与定义了设备间底层交互的[GAP](./chapter3.md)对比，GATT仅处理实际数据传输流程和格式。

GATT也为GATT为基础的配置文件（在第一章的[SIG组织定义的GATT基础配置文件](./chapter1.md#SIG组织定义的GATT基础配置文件)）提供了参照框架，这覆盖了明确的用例和确保来自不同厂商的设备的交互操作性。所有标准BLE配置文件都是基于GATT，并必须基于其进行准确地操作。这使得GATT作为BLE规格书中一个关键的章节，因为每一个关于应用和用户的数据项都必须格式化、打包化、以及根据自身的规则发送。

GATT使用属性协议（详尽参阅第二章[属性协议(ATT)](./chapter2.md#属性协议)）作为自身传输协议来交换设备间的数据。这数据被有层级地按区块组织，并成为*服务（services）*，概念上与用户数据相关联的组称为*特征（characteristics）*。这决定了本章中许多GATT的基础形态。

## 角色

正如蓝牙规格书中任意其他协议或者配置文件，GATT由定义相互交互的设备的角色开始：

*客户端（Client）*

​		GATT客户端与第二章[属性协议(ATT)](./chapter2.md#属性协议)中讨论的ATT客户端相对应。GATT客户端发送请求给服务器并接收其响应包（已启动服务的更新）。GATT客户端起初不知道任何关于服务器的属性，因此必须执行服务发现流程来询问关于这些属性的存在和性质。在完成服务发现流程之后，GATT客户端就可以开始读取已发现的服务中的属性，包括收取已启动服务的更新。

*服务端（server）*

​		GATT服务端与第二章[属性协议(ATT)](./chapter2.md#属性协议)中讨论的ATT服务端相对应。GATT服务端能接受来自客户端的请求并发送应答响应包。在做一些配置情况下，GATT服务端也会发送已启动服务的更新，并且需要作为一个角色负责存储和使客户端能使用用户数据，在属性内组织。每一个已出售的BLE设备都必须包含一个基本的可以响应客户端请求的GATT服务端，甚至仅返回一个错误响应。

值得再次一提的是GATT角色完全不依赖于GAP角色（参见第三章[角色](./chapter3.md#角色)），两者间也同时兼容。这意味着一个GAP中心设备和一个GAP外围设备可以都作为GATT客户端或者服务端，甚至或者同时作为两者存在。

## UUIDs

通用唯一标识符（universally unique identifier, UUID）是一个128位（16字节）确保为（或者很大可能上）全球唯一的数字。除了蓝牙，UUID被用于许多协议和应用，其格式、用法、和产生都在[ITU-T Rec. X.667](bit.ly/1gScfna)被指定，或者是著名的[ISO/IEC 9834-8:2005](bit.ly/1es3R3t)。

为了效率，也因为16字节会占据链路层27字节数据负载的很大一部分，BLE规格书增加了两个额外的UUID格式：16位和32位UUID。这个大大缩短的格式仅用于蓝牙规格书中定义的UUID（也就是，这个是由蓝牙SIG罗列作为标准蓝牙UUID）。

从缩短的UUID版本重建位完整的128位UUID，需要插入蓝牙基本UUID内16或者32位值（由xxxxxxxx表示，包括其实的0）：

​	xxxxxxxx-0000-1000-8000-00805F9B34FB

SIG提供给所有的类型、服务和其定义指定的配置文件一些UUID。但是如果应用需要自己的UUID，不是因为SIG提供的没有满足其需求就是因为想要实现一个之前未在配置配置文件规格书中考虑到的新的用力，可以依照[ITU’s UUID generation page](https://www.itu.int/en/ITU-T/asn1/Pages/UUID/uuids.aspx)生成。

对于不是源自蓝牙基本的UUID（通常称为*厂商指定 vendor-specific* 的UUID），这种缩短的格式是不可以使用的。在这种情况下，你需要从始至终使用完整的128位的UUID。

## 属性

属性（Attributes）为GATT（和ATT）定义的最小的数据实体。他们是可寻址的一些信息，可以包含关于结构的相关用户数据（或者元数据metadata），以及服务端内包含的各种不同的属性。GATT和ATT都可以使用属性进行工作，因此对于客户端和服务端交互，所有的信息都必须按照格式组织。

概念上说，属性总是位于服务端，并由客户端访问（以及修改）。规格书仅概念上定义了属性，并没有强制ATT和GATT使用指定的内部存储格式或者机制执行。因为属性包含了不变性的定义和快速变化的实际用户（通常为传感器）数据（见后文[属性和数据层级](#属性和数据层级)，其内容通常存储在非易失存储器和RAM内。

### 句柄

属性句柄（handle）模块为特定的GATT服务端上的每一个属性的一个唯一16位识别符。其作为每一个属性的一部分使其可寻址，并保证对于绑定的设备在传输、穿越连接中不会改变（在后文[属性缓存](#属性缓存)进行警示）。因为0x0000值表示一个无效的句柄，对于所有的GATT服务端可用的句柄地址为0xFFFE(65535)，尽管实际上服务端上的句柄的数量通常为很小的一打。

​	![bird](D:\work\myCash\book\Getting Started with Bluetooth Low Energy in Chinese\pic\figure-bird.png)	无论何时在属性句柄的环境下使用，*句柄范围*这个术语指包含在两个给定的范围值内所有包含的属性句柄。比如，0x0100-0x010A的句柄范围就指在0x0100-0x010A区间内有句柄的任意一个属性。

在GATT服务端内，句柄增大的值决定了属性可以被客户端访问的排列顺序。但因为在句柄间的间隔空间是允许的，客户端就不能依赖一个连续的序列来猜测下一个属性的位置。相反，哭护短必须使用一个发现特性（在后文[服务和特征发现](#服务和特征发现)）去获得自身感兴趣的属性的句柄。

### 类型

属性类型（type）就仅仅为一个UUID（见前文[UUIDs](#UUIDs)）。这可以是一个16、32、128位的UUID，即分别为2、4、15字节。这类型决定了在属性的数值中的数据，以及基于这些类型各自的发现属性的机制（参照后文[服务和特征发现](#服务和特征发现)）。

### 权限

权限（Permission）是一组指定哪一个ATT操作（见第二章[ATT运作](./chapter2.md#ATT运作)）可以在执行于每一个特定的属性以及指定安全需求的元数据（metadata）。

ATT和GATT定义了以下权限：

*访问权限*

​		与文件权限相似，访问权限（Access Permission）决定了客户端是否可以读或写（或读写）一个*属性值* （参见后文[数值](#数值)）。每一个属性都可以有以下访问权限之一：

​		*无（None）*

​		属性不可被客户端读写。

​		*可读*

​		属性可被客户端读取。

​		*可写*

​		属性可被客户端写入。

​		*可读写*

​		属性可被客户端读写。

*加密*

​		加密（Encryption）个决定了对于被客户端访问的属性是否有一些加密等级的需求。（在认证和加密方面参考第三章[认证](./chapter3.md#认证)、[安全模式和流程](./chapter3.md#安全模式和流程)和[安全模式](./chapter3.md#安全模式)).这些都为允许的加密权限，如GATT定义：

​		*无加密需求（安全模式1，等级1）*

​				这个属性以纯文本、无加密连接的方式访问。

​		*未认证加密需求（安全模式1， 等级2）*

​				该连接必须加密以访问此属性，但是加密钥匙无需认证（虽然也可以认证）。

​		*已认证加密需求（安全模式1， 等级3）*

​				连接必须使用已认证钥匙进行加密，方能访问属性。

*认证*

​		认证（Authorization）决定了访问属性是否需要用户权限（也被理解为认证，见第三章讨论的[安全模式和流程](./chapter3.md#安全模式和流程)）。一个属性仅能需要或不需要认证间作选择：

​		*未加密需求*

​				无需认证访问属性。

​		*加密需求*

​				需认证访问属性。

所有权限都各自独立，并可以由以每一个属性为基础进行储存的服务端自由捆绑。

### 数值

​		属性数值（Value）包含了属性的实际数据内容。对于装载的数据类型没有严格限制（你可以想象其作为一个可以转化成基于属性类型的任意类型的无类型缓存），虽然其最大长度在规格书中被限定为512字节。

后文[属性和数据层级](#属性和数据层级)讨论了，依据属性类型，该数值可以包含关于属性自身或者实际有用的、用户自定义应用数据的额外的数据。这个是客户端可以自由访问进行读写的属性的一部分（在合适的权限请求下）。所有其他的实体组成了属性的结构体，并无法直接被客户端修改或访问（虽然客户端在大多数与服务端交互中间接使用了句柄和UUID）。

你可以视作整个属性为一个表（如[表4-1](#表4-1)）被装载在一个GATT服务端内，每一行表示一个单独的属性，每一列表示实际组成属性的不同部分。

#### 表4-1. 属性表

| 句柄（Handle） | 类型（Type）    | 权限（Permissions）   | 数值（Value）            | 数值长度（Value length） |
| -------------- | --------------- | --------------------- | ------------------------ | ------------------------ |
| 0x0201         | UUID1 (16-bit)  | 可读，无安全性        | 0x180A                   | 2                        |
| 0x0202         | UUID2 (16-bit)  | 可读，无安全性        | 0x2A29                   | 2                        |
| 0x0215         | UUID3 (16-bit)  | 可读/写，需要认证     | 可读UTF-8字符串          | 23                       |
| 0x030C         | UUID4 (128-bit) | 可写，五安全性        | {0xFF, 0xFF, 0x00, 0x00} | 4                        |
| 0x030D         | UUID5 (128-bit) | 可读/写，需要认证加密 | 36.43                    | 8                        |
| 0x031A         | UUID1 (16-bit)  | 可读，无安全性        | 0x1801                   | 2                        |

在这个虚构的GATT服务端中，其装载的属性作为一个表格呈现。这个特殊的GATT服务端掌管了五个属性（相比实际中的设备数量是很少的）。要注意的是，在本章节前文提到，不同属性的句柄为非连续的，但是这个例子还是按照增长排列。

表中的数值的列反映了格式的多样性，这个为在不同GATT配置文件内装载的属性值。0x0201, 0x0202,和0x031A的属性句柄包含了16位其在各自数值区域中的整数。0x0215的属性句柄包含了一个UTF-8的字符串，0x030C包含了一个4字节的缓存数据，0x030D包含了一个IEEE-754 64位的在其数值区域中的浮点数字。

## 属性和数据层级

虽然蓝牙规格书在ATT章节定义了属性，但这是目前为止ATT所能做到的。ATT用属性进行运作，依赖于所有前文[属性](#属性)揭露的一些概念，来提供一系列明确的协议数据单元（PDUs，通常被称为*包 packet*）来允许客户端访问服务器上的属性。

GATT以一个可重复使用和实际的方式进一步建立了一个严格的层级来组织属性，允许客户端和服务端间的信息访问和获取遵循一套简明的规则，其一同组成了由GATT为基础的配置文件使用的框架。

图4-1展示了GATT引入的数据层级。

![figure4-1](./pic/figure4-1.png)

*图4-1. GATT数据层级*

GATT服务端的属性被划分进入*服务（services）*，每一个都包含了零或者更多*特征（characteristics）*。这些特征，依次包含了零或者更多*描述符（descriptors）*。

该层级被任何声称与GATT兼容的设备（实质上，是所有售出的BLE设备）严格执行，这意味着GATT服务器中的所有属性都被包含在这三个类别的其中之一，无一例外。没有一个属性可以在这个层次结构外生存，因为BLE设备间的数据交互都得依赖它。

对于更多在GATT层级中的数据类型，区分它们的*定义（definition）*（组成该层级的所有属性组）和*声明（declaration）*是非常重要的。该声明指的是一个单独的属性，在定义范围内总被列为第一个（在增长的句柄顺序下），这引进了大多的关于其遵循数据的元数据（metadata）。所有的声明都有不需要安全要求的可读权限，因为其不可以包含敏感数据。声明为结构型的属性，允许客户端寻找并发现服务器上属性的布局和性质。

### 服务

GATT服务组概念上与GATT服务端内的属性在属性信息集的一个普通部分相关联。规格书提到在一个单独的服务内的所有属性作为*服务定义（service definition）*。因此，一个GATT服务属性实际上是一连串服务定义，每一个都有一个单独的属性开始，该属性标志了一个服务的开始（恰如命名：*服务声明 a service declaration*）。该属性类型和数值格式在GATT中严格定义，如表4-2展示。

##### 表4-2. 服务声明属性

| 句柄（Handle） | 类型                             | 权限 | 数值     | 数值长度         |
| -------------- | -------------------------------- | ---- | -------- | ---------------- |
| 0xNNNN         | UUID（首服务）或UUID（第二服务） | 只读 | UUID服务 | 2，4，或者16字节 |

在表4-2中展示的声明，UUID（主服务，0x2800）和UUID（第二服务，0x2801）指标准的、SIG指定的作为单独的类型来用于引进一个服务的UUID。其原始形态为16位的UUID（因为这个是由规格书定义的一个基础内容）。

首服务和第二服务间的差别需要重点记录。*首服务（primary service）*是GATT服务的标准类型，包括相关的、标准的由GATT服务端展露的功能。另一方面，*第二服务（secondary service）*是意指为其他首服务包含的内容，进作为其修改器（modifier）方才生效，而自身并没有真正的意义。实际上，第二服务很少被用到。

声明属性服务的内容值自身包含了一个UUID（如前文[数值](#数值)提到，该属性值可以为任何数据类型），与实际的这个声明引进的服务的UUID相绑定。

虽然服务声明必须为该服务的第一个属性，但许多其他的服务也可以在下一个服务声明前跟从，通常使用特征和描述符的格式。

概念上你可以认为一个GATT服务是作为任意现代化面向对象的语言的一个类，连同实例化，因为一个服务可以在一个单独的GATT服务端内被多次实例化（然而，这并不常出现，大部分服务都类似单例模式）。

在一个服务定义内部（就是说，在一个服务里边），你可以使用*包含定义（include definitions）*添加一个或多个引用给其他服务。包含定义由一个单独的属性（包含声明include declaration）组成，包含了所有详尽的关于客户端引用被包含的服务的需求。

被包含的服务（included services）可以帮助避免在GATT服务端中复制数据。如果一个服务将会被其他服务引用，你可以使用这个机制来节省内存空间，并简化GATT服务器的布局。如先前的类和对象的类比，你可以认为包含定义作为现有对象实例的一个指针或者引用。